\documentclass[answers]{exam}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{titling}
\usepackage{float}
\usepackage{csvsimple}

\usepackage{graphicx}
\graphicspath{ {/} }

\newcommand{\oneline}{\fillwithlines{0.25in}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\newcommand{\duedate}{March 4, 2018}
\date{\duedate}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\def\therefore{\boldsymbol{\text{ }
\leavevmode
\lower0.4ex\hbox{$\cdot$}
\kern-.5em\raise0.7ex\hbox{$\cdot$}
\kern-0.55em\lower0.4ex\hbox{$\cdot$}
\thinspace\text{ }}}

\pagestyle{headandfoot}
\headrule
\header{Project 1 Report}{Joseph A. Boyle}{\duedate}

\title{Project 1 Report}
\author{Joseph A. Boyle}

\begin{filecontents*}{baseline_cycles_2.csv}
file, cycles, maxlive, registers
block1.i, 96, 5, 50
block2.i, 81, 12, 44
block3.i, 47, 6, 19
block4.i, 36, 6, 19
block5.i, 75, 5, 49
block6.i, 54, 4, 28
report1.i, 65, 14, 57
report2.i, 62, 5, 37
report3.i, 52, 13, 27
report4.i, 46, 5, 32
report5.i, 50, 19, 41
report6.i, 52, 5, 43
\end{filecontents*}

\begin{document}

\maketitle
\begin{abstract}
In this report, we explore different types of local register allocators and their effectiveness. Specifically, we test two versions of the Top-Down Allocator, each with their own selection heuristic, and a Bottom-Up Allocator. The results of these allocation techniques are evaluated on the number of cycles and instructions needed for execution, through a variety of samples of ILOC code.
\end{abstract}

\section{Introduction}
	We are presented with several snippets of ILOC code which utilize an unbounded number of registers, and utilize one of three allocation techniques to limit the number of registers used to a set number, $k$, while still maintaining code semantics. 
	\subsection{Bottom-Up Allocation}
		In the Bottom-Up allocation scheme, we maintain a list of $k$ registers, and note which of those $k$ are currently free. When a register is needed by an instruction, we can either use one of those free registers, or if none exist, spill one of the in-use registers into memory. In-use registers that are good candidates for spilling are those which aren't going to be used for the longest amount of time in the future, therein allowing other values to take its place, reducing the number of loads for closer instructions. Not depending on a feasible set, $F$, but rather using the given register for loading/storing, all $k$ physical registers may be used for allocation.
		
	\subsection{Top-Down Allocation}
		Top-Down allocation performs a scan of the local block, sorting each virtual register by its number of uses. Using some selection heuristic, we decide which of the virtual registers are best to keep in physical registers and which should be loaded in as needed, generally sorted by usage. These type of allocators require some feasible set, $F$, of registers for loading/storing values, and as such we are only allowed to use $(k-F)$ registers for allocation, reserving the other $F$ registers for loading/storing values from memory as needed. In ILOC, the feasible set contains 2 registers (that is, $F = 2$), but we will use $F$ throughout this discussion to ensure generality.
		
		There are two variants of Top-Down allocation tested in this report. One approach, demonstrated in \textit{Engineering: A Compiler}, computes the number of times each virtual register occurs, and uses the $(k-F)$ registers which occur most as the physical registers, and spill the other virtual registers. Another approach, which we utilized in class, computes the MAXLIVE (the number of virtual registers live at a given instruction) for each instruction, and then visits each instruction such that MAXLIVE $ \geq (k-F)$, in textual order, and spills one virtual register contributing to the MAXLIVE that is used in the current instruction. The MAXLIVE is then recalculated, and this cycle continues until all instructions have a MAXLIVE $< (k-F)$.
	
	\subsection{Language and Design Choices}
		We used C to implement these allocators, given its speed and fairly easy to use syntax. Reading instructions from the source file is done via a quick interpreter which doesn't maintain the state of what each instruction expects. That is, we interpret an OP-code, and then read is as many arguments as are supplied, interpreting if they're inputs, outputs, immediate values, registers, etc, as they're loaded. It is entirely possible to feed invalid instructions (e.g: \textit{loadAI r0, r1 $=>$ r2, r3}). Since it was said that there are only legal instructions fed in via input files, this was deemed okay, but this could present some problems in producing semantically correct output code.
		
		C also has the advantage of pointers. The program represents each instruction as its own struct, which in turn has structs representing its arguments. When it comes time to actually assign registers, a combination of a Register struct and some nifty use of arrays makes the sorting, storage, and allocation of arrays quite painless.
		
	\section{Results}
		Implementation wise, the hardest to implement was the Top-Down allocator used in class. This was largely due to not including MAXLIVE calculations in the code from the beginning, and having to restructure the way instructions are interpreted. Testing of all of the files was done via a series of C and bash scripts. One bash script was used to automate the register-allocated code (plus calculate the time to do the allocation), while another was used to handle moving result files around. These two scripts were run through a C program that verified the results of the various file allocators (with differing register counts) with that of their original file, and generated CSVs that could be used to create charts, tables, etc.
		
		All of our tests were performed locally and on the ilab machine, \textit{cpp.cs.rutgers.edu}, using the Linux program \textit{time} and recording the \textbf{real} time measurement. 
		
		\begin{figure}[H]
			\centering
			\begin{tabular}{c|c|c|c}%
				 \bfseries Block Name & \bfseries Number Cycles & \bfseries MAXLIVE & \bfseries Number of Registers
				\csvreader[head to column names]{baseline_cycles_2.csv}{}% use head of csv as column names
				{\\\hline \file & \cycles & \maxlive & \registers}
			\end{tabular}
			\caption{The number of cycles, registers, and MAXLIVE for each of the blocks used in testing with an unbounded number of virtual registers.}
		\end{figure}
		\subsection{Bottom Up}
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.43]{b_cycles.png}
				\caption{In order, the number of cycles for the bottom-up allocator for 5, 10, and 20 registers for each of block1, block2, \dots, report 6. i.e: column 4 is 5 registers for block 2.}
			\end{figure}
	
			Observing the number of cycles required as the number of registers increase is unsurprising at first glance -- less registers are required to be spilled as $k$ increases. Since Bottom-Up allocators require no Feasible set $F$, all $k$ physical registers are able to be used throughout the allocated program. In blocks where MAXLIVE is $< k$, then, we find that the performance of the allocator is equivalent to the performance of the block without allocation, in terms of cycles. The upside of using the allocator, then, is the reduction in the number of registers: in \textit{block1}, for example, we can do with $k = 6$ registers and achieve the same number of cycles as the program written using $k = 50$ registers. 
			
			This is a major upside when writing a compiler, so long as we assume that the values aren't intertwined too much. If users of the language are conscious of this and use variables 
			

\end{document}